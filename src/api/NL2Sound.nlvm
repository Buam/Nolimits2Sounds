package api;

import com.nolimitscoaster.*;
import nlvm.math3d.*;

public abstract class NL2Sound implements FrameListener, TrackTriggerListener {

    private String id;

    private Coaster coaster;
    private StaticSound[] sounds;
    private StaticSound[] ends;
    private Train[] trains;
    private Section[] sections; // Normal Sections
    private TrackTrigger[] triggers; // Sections made of Triggers
    private String[] triggerStr; // Names of the Triggers listed above

    protected bool hasEndAudio = true;
    protected bool[] isInTriggerSection;
    protected bool[] isPlaying;

    public NL2Sound(String id) {
        this.id = id;
    }

    public String getId() {
        return this.id;
    }

    public void init(Simulator sim, Coaster coaster) {
        this.coaster = coaster;

        this.sounds = new StaticSound[coaster.getTrainCount()];
        this.ends = new StaticSound[coaster.getTrainCount()];
        this.trains = new Train[coaster.getTrainCount()];
        this.isPlaying = new bool[coaster.getTrainCount()];
        this.isInTriggerSection = new bool[coaster.getTrainCount()];

        this.hasEndAudio = StaticSound.loadFromResourceId(this.id + "_end", 0) != null;

        for(int i = 0; i < coaster.getTrainCount(); i++)
        {
            this.trains[i] = coaster.getTrainAt(i);
            this.sounds[i] = StaticSound.loadFromResourceId(this.id, 0);
            this.isPlaying[i] = false;
            this.isInTriggerSection[i] = false;
            this.onInit(this.sounds[i]);

            if (this.hasEndAudio) {
                this.ends[i] = StaticSound.loadFromResourceId(this.id + "_end", 0);
                this.onInit(this.ends[i]);
            }
        }

        this.initSections();

        // Register End Triggers
        for (int i = 0; i < this.sections.length; i++) {
            if (this.coaster.getTrackTrigger(this.sections[i].getName() + "_end") != null) {
                this.coaster.getTrackTrigger(this.sections[i].getName() + "_end").addTrackTriggerListener(this);
            }
        }

        for (int i = 0; i < this.triggers.length; i++) {
            this.coaster.getTrackTrigger(this.triggerStr[i]).addTrackTriggerListener(this);
            if (this.coaster.getTrackTrigger(this.triggerStr[i] + "_end") != null) {
                this.coaster.getTrackTrigger(this.triggerStr[i] + "_end").addTrackTriggerListener(this);
            } else {
                System.out.println(this.triggerStr[i] + " does not have an Endpoint.");
            }
        }

        sim.addFrameListener(this);
    }

    private void initSections() {
        bool hasSingleSection = false;
        bool hasSingleTrigger = false;

        if (coaster.getSection(id) != null)
            hasSingleSection = true;

        if (coaster.getTrackTrigger(id) != null)
            hasSingleTrigger = true;

        if (hasSingleSection && hasSingleTrigger)
            System.err.println("Duplicate Section/Trigger found! (" + id + ")");

        int n = 1; // Total Count
        int n_s = 1; // Section Count
        int n_t = 1; // Trigger Count
        while (coaster.getSection(this.id + "_" + n) != null || coaster.getTrackTrigger(this.id + "_" + n) != null) {
            bool dupl = false;
            if (coaster.getSection(this.id + "_" + n) != null) {
                n_s++;
                dupl = true;
            }
            if (coaster.getTrackTrigger(this.id + "_" + n) != null) {
                n_t++;
                if (dupl) {
                    System.err.println("Duplicate Section/Trigger found! (" + this.id + "_" + n + ")");
                }
            }
            n++;
        }

        if (hasSingleSection) {
            this.sections = new Section[n_s];
            this.sections[0] = coaster.getSection(id);
        } else {
            this.sections = new Section[n_s-1];
        }

        if (hasSingleTrigger) {
            this.triggers = new TrackTrigger[n_t];
            this.triggerStr = new String[n_t];
            this.triggers[0] = coaster.getTrackTrigger(id);
            this.triggerStr[0] = id;
        } else {
            this.triggers = new TrackTrigger[n_t-1];
            this.triggerStr = new String[n_t-1];
        }

        int c_s = 1;
        int c_t = 1;
        for (int i = 1; i < n; i++) {
            if (coaster.getSection(this.id + "_" + i) != null) {
                if (!hasSingleSection) {
                    this.sections[c_s-1] = coaster.getSection(this.id + "_" + i);
                } else {
                    this.sections[c_s] = coaster.getSection(this.id + "_" + i);
                }
                c_s++;
            }

            if (coaster.getTrackTrigger(this.id + "_" + i) != null) {
                if (!hasSingleTrigger) {
                    this.triggers[c_t-1] = coaster.getTrackTrigger(this.id + "_" + i);
                    this.triggerStr[c_t-1] = this.id + "_" + i;
                } else {
                    this.triggers[c_t] = coaster.getTrackTrigger(this.id + "_" + i);
                    this.triggerStr[c_t] = this.id + "_" + i;
                }
                c_t++;
            }
        }
    }

    public void onNextFrame() {
        for (int i = 0; i < coaster.getTrainCount(); i++) {

            if (this.isPlaying[i]) {

                Vector3f pos = new Vector3f(0, 0, 0);
                this.trains[i].getBogieOrientationAndPosition(0, null, null, null, pos);
                this.sounds[i].setPosition(pos);
                this.onFrame(this.sounds[i], this.trains[i]);

                if (!this.shouldPlay(this.coaster, this.trains[i])) {
                    this.stop(this.sounds[i], this.trains[i]);
                    this.isPlaying[i] = false;
                }

            } else {

                if (this.shouldPlay(this.coaster, this.trains[i])) {
                    this.play(this.sounds[i], this.trains[i]);
                    this.isPlaying[i] = true;
                }
            }
        }
    }

    public void onTrainEntering(TrackTrigger trigger, Train train) {
        int t = this.getTrainId(train);
        for (int i = 0; i < this.sections.length; i++) {
            if (this.coaster.getTrackTrigger(this.sections[i].getName() + "_end") == trigger) {
                this.stop(this.sounds[t], train);
                if (this.hasEndAudio) {
                    Vector3f pos = new Vector3f(0, 0, 0);
                    train.getBogieOrientationAndPosition(0, null, null, null, pos);
                    this.ends[t].setPosition(pos);
                    this.playEnd(ends[t], train);
                }
                return;
            }
        }
        for (int i = 0; i < this.triggers.length; i++) {
            if (this.triggers[i] == trigger) {
                this.isInTriggerSection[t] = true;
                return;
            } else if (this.coaster.getTrackTrigger(this.triggerStr[i] + "_end") == trigger) {
                this.isInTriggerSection[t] = false;
                if (this.hasEndAudio) {
                    Vector3f pos = new Vector3f(0, 0, 0);
                    train.getBogieOrientationAndPosition(0, null, null, null, pos);
                    this.ends[i].setPosition(pos);
                    this.playEnd(ends[i], train);
                }
                return;
            }
        }
    }

    protected int getTrainId(Train train) {
        for (int i = 0; i < this.trains.length; i++) {
            if (this.trains[i] == train) {
                return i;
            }
        }
        return -1; // This should NEVER be returned
    }

    public void onTrainLeaving(TrackTrigger trigger, Train train) {}

    // ABSTRACT METHODS

    /**
    * Gets called once the simulation is started. Use this method to set default parameters.
    */
    public void onInit(StaticSound sound) {
        sound.setGain(0.0f);
    }
    
    /**
    * Returns true or false whether the sound should play or not.
    * Don't change this method if you want the sound to play while the train is on the desired section.
    * Always return true if you want the sound to be global.
    */
    public bool shouldPlay(Coaster coaster, Train train) {
        for (int i = 0; i < this.sections.length; i++) {
            if (sections[i].getTrainOnSection() == train) {
                return true;
            }
        }

        if (this.isInTriggerSection[this.getTrainId(train)])
            return true;

        return false;
    }

    /**
    * Called once every Frame while the sound is playing. Won't get called, if the sound isn't playing.
    */
    public void onFrame(StaticSound sound, Train train) {
    }

    /**
    * Starts playing the Sound.
    */
    public void play(StaticSound sound, Train train) {
        sound.playLoop();
    }

    /**
    * Starts playing the End Sound.
    */
    public void playEnd(StaticSound sound, Train train) {
        sound.setGain(1.0f);
        sound.play();
    }

    /**
    * Stops playing the Sound.
    */
    public void stop(StaticSound sound, Train train) {
        sound.stop();
    }
}
